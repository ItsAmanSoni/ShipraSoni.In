---
title: "React Native: Building Cross-Platform Apps That Don't Compromise"
summary: "From developing the enterprise energy sector client mobile app at Advaiya Solutions, learn how React Native delivers native performance with JavaScript and why it's the go-to choice for modern cross-platform development."
publishedAt: "2025-01-10"
image: "/images/blog/blog-7.jpeg"
tag: "Mobile Development"
---

## The Mobile Development Dilemma

When the enterprise energy sector client project landed on the desk at Advaiya Solutions with a requirement for both iOS and Android apps within 12 weeks, the team faced a critical decision: build natively twice (24 weeks) or find a better way.

React Native wasn't just a compromise—it became the solution that delivered native quality in half the time.

## What Makes React Native Special

### Not Just Another Hybrid Framework

**Traditional Hybrid (Cordova/Ionic):**
- WebView rendering
- Not truly native
- Performance limitations
- "Uncanny valley" user experience

**React Native:**
- Real native components
- JavaScript logic layer
- Native rendering
- True native performance

<CodeBlock compact marginBottom="16" codes={[
  {
    code: `// React Native renders real native components
<View> → UIView (iOS) / android.view.View (Android)
<Text> → UILabel (iOS) / android.widget.TextView (Android)
<Image> → UIImage (iOS) / android.widget.ImageView (Android)

// Not a WebView - actual platform UI components!`,
    language: "javascript"
  }
]} />

## Real Project: enterprise energy sector client Mobile App

### Requirements:
- User authentication with SSO
- Real-time bill tracking
- Payment integration
- Offline functionality
- Push notifications
- Both iOS and Android
- Timeline: 12 weeks

### The React Native Advantage:

**Code Sharing:**
- Business logic: 95% shared
- UI components: 85% shared
- Platform-specific: 15%
- Total code reuse: ~90%

**Result:**
- Delivered in 11 weeks
- Single codebase
- 4 developers instead of 8
- Native performance
- Happy client

## Architecture Patterns That Work

### 1. Component Structure

<CodeBlock compact marginBottom="16" codes={[
  {
    code: `// Project structure from enterprise energy sector client app
src/
├── components/
│   ├── common/          // Shared UI components
│   │   ├── Button.tsx
│   │   ├── Input.tsx
│   │   └── Card.tsx
│   ├── features/        // Feature-specific components
│   │   ├── Auth/
│   │   ├── Billing/
│   │   └── Payments/
├── screens/             // Screen components
│   ├── HomeScreen.tsx
│   ├── BillScreen.tsx
│   └── ProfileScreen.tsx
├── navigation/          // Navigation setup
├── store/              // Redux state
├── services/           // API calls
├── utils/              // Helper functions
└── hooks/              // Custom hooks`,
    language: "text"
  }
]} />

### 2. State Management with Redux

<CodeBlock compact marginBottom="16" codes={[
  {
    code: `// Redux setup for enterprise energy sector client app
import { configureStore } from '@reduxjs/toolkit';
import { persistStore, persistReducer } from 'redux-persist';
import AsyncStorage from '@react-native-async-storage/async-storage';

const persistConfig = {
  key: 'root',
  storage: AsyncStorage,
  whitelist: ['auth', 'bills'] // Persist auth and bills
};

export const store = configureStore({
  reducer: {
    auth: authReducer,
    bills: billsReducer,
    payments: paymentsReducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: false, // For Redux Persist
    }),
});`,
    language: "typescript"
  }
]} />

### 3. Navigation with React Navigation

<CodeBlock compact marginBottom="16" codes={[
  {
    code: `// Navigation structure
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';

const Tab = createBottomTabNavigator();
const Stack = createNativeStackNavigator();

function MainTabs() {
  return (
    <Tab.Navigator>
      <Tab.Screen name="Home" component={HomeScreen} />
      <Tab.Screen name="Bills" component={BillsScreen} />
      <Tab.Screen name="Profile" component={ProfileScreen} />
    </Tab.Navigator>
  );
}

function App() {
  return (
    <NavigationContainer>
      <Stack.Navigator>
        {isLoggedIn ? (
          <Stack.Screen name="Main" component={MainTabs} />
        ) : (
          <Stack.Screen name="Login" component={LoginScreen} />
        )}
      </Stack.Navigator>
    </NavigationContainer>
  );
}`,
    language: "typescript"
  }
]} />

## Performance Optimization

### Problem: List Performance

**Scenario:** Displaying 1000+ bill records

**Bad Approach:**
<CodeBlock compact marginBottom="16" codes={[
  {
    code: `// Don't do this - renders all items
<ScrollView>
  {bills.map(bill => <BillItem key={bill.id} bill={bill} />)}
</ScrollView>
// Result: Slow, memory issues`,
    language: "typescript"
  }
]} />

**Good Approach:**
<CodeBlock compact marginBottom="16" codes={[
  {
    code: `// Use FlatList for virtualization
<FlatList
  data={bills}
  renderItem={({ item }) => <BillItem bill={item} />}
  keyExtractor={item => item.id}
  windowSize={10}
  maxToRenderPerBatch={10}
  updateCellsBatchingPeriod={50}
  initialNumToRender={10}
  removeClippedSubviews={true}
  getItemLayout={(data, index) => ({
    length: ITEM_HEIGHT,
    offset: ITEM_HEIGHT * index,
    index,
  })}
/>
// Result: Smooth 60 FPS with 10K items`,
    language: "typescript"
  }
]} />

**Improvement:** From 15 FPS to 60 FPS

### Memoization Strategy

<CodeBlock compact marginBottom="16" codes={[
  {
    code: `// Prevent unnecessary re-renders
import React, { memo, useMemo, useCallback } from 'react';

const BillItem = memo(({ bill, onPress }) => {
  // Only re-renders if bill or onPress changes
  return (
    <TouchableOpacity onPress={() => onPress(bill.id)}>
      <Text>{bill.amount}</Text>
      <Text>{bill.dueDate}</Text>
    </TouchableOpacity>
  );
});

function BillsList() {
  const bills = useSelector(state => state.bills.list);

  // Memoize expensive calculations
  const totalAmount = useMemo(() =>
    bills.reduce((sum, bill) => sum + bill.amount, 0),
    [bills]
  );

  // Memoize callbacks
  const handlePress = useCallback((id) => {
    navigation.navigate('BillDetail', { id });
  }, [navigation]);

  return <FlatList data={bills} renderItem={...} />;
}`,
    language: "typescript"
  }
]} />

## Platform-Specific Code

### When You Need Native Features

<CodeBlock compact marginBottom="16" codes={[
  {
    code: `// File: BiometricAuth.ios.tsx
import TouchID from 'react-native-touch-id';

export async function authenticate() {
  return await TouchID.authenticate('Unlock enterprise energy sector client App', {
    fallbackLabel: 'Use Passcode'
  });
}

// File: BiometricAuth.android.tsx
import ReactNativeBiometrics from 'react-native-biometrics';

export async function authenticate() {
  const { success } = await ReactNativeBiometrics.simplePrompt({
    promptMessage: 'Unlock enterprise energy sector client App'
  });
  return success;
}

// Usage: React Native auto-imports correct file
import { authenticate } from './BiometricAuth';
// Uses .ios.tsx on iOS, .android.tsx on Android`,
    language: "typescript"
  }
]} />

## SSO Authentication Implementation

**Challenge:** Implement enterprise SSO for enterprise energy sector client

<CodeBlock compact marginBottom="16" codes={[
  {
    code: `// OAuth 2.0 + PKCE implementation
import { authorize } from 'react-native-app-auth';

const config = {
  issuer: 'https://auth.bses.com',
  clientId: 'bses-mobile-app',
  redirectUrl: 'com.bses.app://oauth',
  scopes: ['openid', 'profile', 'email'],
  usePKCE: true, // Proof Key for Code Exchange
};

async function handleSSO() {
  try {
    const result = await authorize(config);

    // Store tokens securely
    await SecureStore.setItemAsync('accessToken', result.accessToken);
    await SecureStore.setItemAsync('refreshToken', result.refreshToken);

    // Update Redux state
    dispatch(loginSuccess(result));

    return result;
  } catch (error) {
    console.error('SSO failed:', error);
    throw error;
  }
}

// Token refresh
async function refreshAccessToken() {
  const refreshToken = await SecureStore.getItemAsync('refreshToken');

  const result = await refresh(config, {
    refreshToken: refreshToken,
  });

  await SecureStore.setItemAsync('accessToken', result.accessToken);
  return result.accessToken;
}`,
    language: "typescript"
  }
]} />

## Offline-First Architecture

**Requirement:** App must work without internet

<CodeBlock compact marginBottom="16" codes={[
  {
    code: `// Offline-first with Redux Persist + NetInfo
import NetInfo from '@react-native-community/netinfo';
import { createSlice } from '@reduxjs/toolkit';

// Track network status
const networkSlice = createSlice({
  name: 'network',
  initialState: { isConnected: true, queue: [] },
  reducers: {
    setConnectionStatus: (state, action) => {
      state.isConnected = action.payload;
    },
    addToQueue: (state, action) => {
      state.queue.push(action.payload);
    },
    processQueue: (state) => {
      // Process queued requests when back online
      state.queue = [];
    }
  }
});

// Listen to network changes
NetInfo.addEventListener(state => {
  store.dispatch(setConnectionStatus(state.isConnected));

  if (state.isConnected) {
    // Process offline queue
    store.dispatch(processQueue());
  }
});

// API middleware for offline handling
const offlineMiddleware = store => next => action => {
  if (action.type.endsWith('/pending')) {
    const { isConnected } = store.getState().network;

    if (!isConnected) {
      // Queue the request
      store.dispatch(addToQueue(action));
      return; // Don't execute now
    }
  }

  return next(action);
};`,
    language: "typescript"
  }
]} />

## Push Notifications

**Implementation for enterprise energy sector client:**

<CodeBlock compact marginBottom="16" codes={[
  {
    code: `// Firebase Cloud Messaging setup
import messaging from '@react-native-firebase/messaging';
import notifee from '@notifee/react-native';

// Request permission
async function requestPermission() {
  const authStatus = await messaging().requestPermission();
  const enabled =
    authStatus === messaging.AuthorizationStatus.AUTHORIZED ||
    authStatus === messaging.AuthorizationStatus.PROVISIONAL;

  if (enabled) {
    const token = await messaging().getToken();
    // Send token to backend
    await api.post('/users/fcm-token', { token });
  }
}

// Handle foreground notifications
messaging().onMessage(async remoteMessage => {
  // Display custom notification
  await notifee.displayNotification({
    title: remoteMessage.notification.title,
    body: remoteMessage.notification.body,
    android: {
      channelId: 'default',
      pressAction: {
        id: 'default',
      },
    },
  });
});

// Handle background/quit state
messaging().setBackgroundMessageHandler(async remoteMessage => {
  console.log('Background message:', remoteMessage);
});

// Handle notification tap
notifee.onBackgroundEvent(async ({ type, detail }) => {
  if (type === EventType.PRESS) {
    // Navigate to relevant screen
    navigation.navigate('BillDetail', { id: detail.notification.data.billId });
  }
});`,
    language: "typescript"
  }
]} />

## Payment Integration

**Razorpay Integration for Bill Payments:**

<CodeBlock compact marginBottom="16" codes={[
  {
    code: `import RazorpayCheckout from 'react-native-razorpay';

async function handlePayment(bill) {
  const options = {
    description: \`Bill Payment - \${bill.id}\`,
    image: 'https://bses.com/logo.png',
    currency: 'INR',
    key: RAZORPAY_KEY_ID,
    amount: bill.amount * 100, // Amount in paise
    name: 'enterprise energy sector client Bill Payment',
    order_id: bill.orderId, // From backend
    prefill: {
      email: user.email,
      contact: user.phone,
      name: user.name,
    },
    theme: { color: '#0066CC' }
  };

  try {
    const data = await RazorpayCheckout.open(options);

    // Payment successful
    await api.post('/bills/payment-success', {
      billId: bill.id,
      paymentId: data.razorpay_payment_id,
      signature: data.razorpay_signature,
    });

    dispatch(markBillPaid(bill.id));

    Alert.alert('Success', 'Payment completed successfully!');
  } catch (error) {
    Alert.alert('Error', 'Payment failed. Please try again.');
  }
}`,
    language: "typescript"
  }
]} />

## Testing Strategy

### Unit Tests with Jest

<CodeBlock compact marginBottom="16" codes={[
  {
    code: `// __tests__/BillItem.test.tsx
import { render, fireEvent } from '@testing-library/react-native';
import BillItem from '../BillItem';

describe('BillItem', () => {
  const mockBill = {
    id: '1',
    amount: 1500,
    dueDate: '2025-02-15',
    status: 'pending'
  };

  it('renders bill details correctly', () => {
    const { getByText } = render(
      <BillItem bill={mockBill} onPress={jest.fn()} />
    );

    expect(getByText('₹1,500')).toBeTruthy();
    expect(getByText('Due: 15 Feb 2025')).toBeTruthy();
  });

  it('calls onPress when tapped', () => {
    const onPress = jest.fn();
    const { getByTestId } = render(
      <BillItem bill={mockBill} onPress={onPress} />
    );

    fireEvent.press(getByTestId('bill-item'));
    expect(onPress).toHaveBeenCalledWith(mockBill.id);
  });
});`,
    language: "typescript"
  }
]} />

### E2E Tests with Detox

<CodeBlock compact marginBottom="16" codes={[
  {
    code: `// e2e/login.test.js
describe('Login Flow', () => {
  beforeAll(async () => {
    await device.launchApp();
  });

  it('should login successfully with valid credentials', async () => {
    await element(by.id('email-input')).typeText('user@example.com');
    await element(by.id('password-input')).typeText('password123');
    await element(by.id('login-button')).tap();

    await waitFor(element(by.id('home-screen')))
      .toBeVisible()
      .withTimeout(5000);
  });

  it('should show error with invalid credentials', async () => {
    await element(by.id('email-input')).typeText('wrong@example.com');
    await element(by.id('password-input')).typeText('wrong');
    await element(by.id('login-button')).tap();

    await expect(element(by.text('Invalid credentials'))).toBeVisible();
  });
});`,
    language: "javascript"
  }
]} />

## Common Pitfalls and Solutions

### Pitfall 1: Memory Leaks

**Problem:** Subscriptions not cleaned up

<CodeBlock compact marginBottom="16" codes={[
  {
    code: `// Bad - memory leak
useEffect(() => {
  const subscription = eventEmitter.on('bill-updated', handleUpdate);
  // Missing cleanup!
}, []);

// Good - proper cleanup
useEffect(() => {
  const subscription = eventEmitter.on('bill-updated', handleUpdate);

  return () => {
    subscription.remove(); // Cleanup!
  };
}, []);`,
    language: "typescript"
  }
]} />

### Pitfall 2: Large Bundle Size

**Solution:** Code splitting and lazy loading

<CodeBlock compact marginBottom="16" codes={[
  {
    code: `// Lazy load heavy screens
const PaymentScreen = lazy(() => import('./screens/PaymentScreen'));
const ReportsScreen = lazy(() => import('./screens/ReportsScreen'));

// Use React.Suspense
<Suspense fallback={<LoadingScreen />}>
  <PaymentScreen />
</Suspense>

// Result: Initial bundle reduced from 3.2MB to 1.8MB`,
    language: "typescript"
  }
]} />

### Pitfall 3: Android Back Button

**Solution:** Handle back button properly

<CodeBlock compact marginBottom="16" codes={[
  {
    code: `import { BackHandler } from 'react-native';

useEffect(() => {
  const backHandler = BackHandler.addEventListener(
    'hardwareBackPress',
    () => {
      if (navigation.canGoBack()) {
        navigation.goBack();
        return true; // Prevent default
      }
      return false; // Allow app exit
    }
  );

  return () => backHandler.remove();
}, [navigation]);`,
    language: "typescript"
  }
]} />

## Deployment Strategy

### iOS Deployment

<CodeBlock compact marginBottom="16" codes={[
  {
    code: `# Fastlane setup for enterprise energy sector client app
# fastlane/Fastfile

lane :beta do
  increment_build_number
  build_app(scheme: "enterprise energy sector client")
  upload_to_testflight(
    skip_waiting_for_build_processing: true
  )
  slack(message: "New iOS build uploaded to TestFlight")
end

lane :release do
  build_app(scheme: "enterprise energy sector client")
  upload_to_app_store
  slack(message: "New iOS version submitted for review")
end`,
    language: "ruby"
  }
]} />

### Android Deployment

<CodeBlock compact marginBottom="16" codes={[
  {
    code: `# Fastlane for Android
lane :beta do
  gradle(
    task: "bundle",
    build_type: "Release"
  )
  upload_to_play_store(
    track: "internal",
    aab: "android/app/build/outputs/bundle/release/app-release.aab"
  )
end

lane :release do
  gradle(task: "bundle", build_type: "Release")
  upload_to_play_store(
    track: "production",
    aab: "android/app/build/outputs/bundle/release/app-release.aab"
  )
end`,
    language: "ruby"
  }
]} />

## Results: enterprise energy sector client App Success Metrics

**Performance:**
- App launch time: 1.2s
- Screen transition: < 16ms (60 FPS)
- API response handling: 50ms average
- Battery usage: Optimized (< 2% per hour active use)

**User Metrics (3 months post-launch):**
- Downloads: 50,000+
- Active users: 35,000+
- App Store rating: 4.6/5
- Play Store rating: 4.5/5
- Crash-free rate: 99.7%

**Business Impact:**
- Development cost: 60% lower than native
- Time to market: 50% faster
- Maintenance: Single codebase
- Feature parity: 100% across platforms

## When to Choose React Native

### ✅ Perfect For:

1. **Apps that need both iOS and Android**
   - 90% code sharing
   - Single team
   - Faster delivery

2. **Startups and MVPs**
   - Rapid development
   - Cost-effective
   - Easy to iterate

3. **Apps with web counterpart**
   - Share components with React web
   - Consistent logic
   - Reusable skills

4. **Standard app features**
   - Forms, lists, navigation
   - API integration
   - Push notifications
   - Authentication

### ❌ Not Ideal For:

1. **Heavy 3D graphics**
   - Games
   - AR/VR apps
   - Complex animations

2. **Platform-specific features**
   - Heavy Bluetooth/NFC
   - Complex camera features
   - Advanced sensors

3. **Performance-critical apps**
   - Real-time video editing
   - Audio processing
   - Scientific calculations

## The Future: React Native's Evolution

**Upcoming Features (2025-2026):**
- New Architecture (Fabric + TurboModules)
- Better performance
- Smaller bundle sizes
- Faster startup time
- Improved debugging

**Already Live:**
- Hermes engine for better performance
- Fast Refresh for instant updates
- TypeScript support out of the box
- Expo SDK 50+ features

## Conclusion: The Right Tool for Modern Mobile

React Native isn't a compromise—it's a strategic choice. At Advaiya Solutions, it enabled delivery of a complex enterprise mobile app in half the time with half the team.

**Key Takeaways:**
- 90% code sharing is real
- Native performance is achievable
- Single team can handle both platforms
- Cost and time savings are substantial
- Enterprise-ready with proper architecture

**Aman's Recommendation:**
For 80% of mobile apps, React Native is the smart choice. The 20% that need fully native development know who they are (games, AR/VR, specialized hardware integration).

**Start building cross-platform apps that don't compromise on quality.**

---

*Based on production experience building the enterprise energy sector client mobile app at Advaiya Solutions, delivered to 50,000+ users with 4.5+ star ratings on both platforms.*
