---
title: "API Integration Patterns: Lessons from Building a B2B Marketplace"
summary: "Learn battle-tested API integration patterns from building Sahyog Medico's B2B marketplace, integrating Razorpay payments, ShipRocket logistics, and multiple third-party services."
publishedAt: "2025-01-08"
image: "/images/blog/blog-9.jpeg"
tag: "Backend Development"
---

## The Integration Challenge

Building Sahyog Medico's B2B medical supplies marketplace meant integrating with multiple external services: Razorpay for payments, ShipRocket for shipping, SMS gateways, email services, and inventory management systems. Each API had its quirks, different authentication methods, varying rate limits, and unique error handling requirements.

This is the reality of modern full-stack development—your app is only as good as your integrations.

## The Foundation: HTTP Client Architecture

### The Wrong Way (Don't Do This)

<CodeBlock compact marginBottom="16" codes={[
  {
    code: `// Bad: Axios everywhere, no consistency
const getProducts = async () => {
  const response = await axios.get('https://api.supplier.com/products', {
    headers: { 'Authorization': 'Bearer token123' }
  });
  return response.data;
};

// Different error handling everywhere
// No logging
// No retry logic
// Authentication scattered`,
    language: "typescript"
  }
]} />

### The Right Way: Centralized HTTP Client

<CodeBlock compact marginBottom="16" codes={[
  {
    code: `// api/httpClient.ts
import axios, { AxiosInstance, AxiosRequestConfig } from 'axios';

class HttpClient {
  private client: AxiosInstance;
  private retryCount = 3;

  constructor(baseURL: string) {
    this.client = axios.create({
      baseURL,
      timeout: 30000,
      headers: {
        'Content-Type': 'application/json',
      },
    });

    this.setupInterceptors();
  }

  private setupInterceptors() {
    // Request interceptor
    this.client.interceptors.request.use(
      (config) => {
        // Add auth token
        const token = getAuthToken();
        if (token) {
          config.headers.Authorization = \`Bearer \${token}\`;
        }

        // Log request
        logger.info('API Request:', {
          method: config.method,
          url: config.url,
          data: config.data,
        });

        return config;
      },
      (error) => {
        logger.error('Request error:', error);
        return Promise.reject(error);
      }
    );

    // Response interceptor
    this.client.interceptors.response.use(
      (response) => {
        logger.info('API Response:', {
          status: response.status,
          data: response.data,
        });
        return response;
      },
      async (error) => {
        return this.handleError(error);
      }
    );
  }

  private async handleError(error: any) {
    const originalRequest = error.config;

    // Retry logic for network errors
    if (!error.response && originalRequest._retry < this.retryCount) {
      originalRequest._retry = (originalRequest._retry || 0) + 1;

      await delay(1000 * originalRequest._retry); // Exponential backoff
      return this.client(originalRequest);
    }

    // Handle 401 - refresh token
    if (error.response?.status === 401) {
      await refreshAuthToken();
      return this.client(originalRequest);
    }

    // Log error
    logger.error('API Error:', {
      status: error.response?.status,
      message: error.message,
      url: originalRequest.url,
    });

    return Promise.reject(error);
  }

  async get<T>(url: string, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.client.get<T>(url, config);
    return response.data;
  }

  async post<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.client.post<T>(url, data, config);
    return response.data;
  }

  // ... put, patch, delete methods
}

// Export instances for different services
export const apiClient = new HttpClient(process.env.API_BASE_URL);
export const razorpayClient = new HttpClient('https://api.razorpay.com/v1');
export const shiprocketClient = new HttpClient('https://apiv2.shiprocket.in/v1');`,
    language: "typescript"
  }
]} />

## Pattern 1: Payment Gateway Integration (Razorpay)

### Challenge: Secure Payment Processing

<CodeBlock compact marginBottom="16" codes={[
  {
    code: `// services/payment.service.ts
import Razorpay from 'razorpay';
import crypto from 'crypto';

class PaymentService {
  private razorpay: Razorpay;

  constructor() {
    this.razorpay = new Razorpay({
      key_id: process.env.RAZORPAY_KEY_ID!,
      key_secret: process.env.RAZORPAY_KEY_SECRET!,
    });
  }

  // Step 1: Create order on backend
  async createOrder(amount: number, currency: string = 'INR') {
    try {
      const order = await this.razorpay.orders.create({
        amount: amount * 100, // Convert to paise
        currency,
        receipt: \`receipt_\${Date.now()}\`,
        payment_capture: 1, // Auto capture
      });

      // Store order in database
      await db.orders.create({
        orderId: order.id,
        amount: order.amount,
        currency: order.currency,
        status: 'created',
      });

      return {
        orderId: order.id,
        amount: order.amount,
        currency: order.currency,
      };
    } catch (error) {
      logger.error('Order creation failed:', error);
      throw new Error('Failed to create payment order');
    }
  }

  // Step 2: Verify payment signature
  verifyPaymentSignature(
    orderId: string,
    paymentId: string,
    signature: string
  ): boolean {
    const text = \`\${orderId}|\${paymentId}\`;
    const generatedSignature = crypto
      .createHmac('sha256', process.env.RAZORPAY_KEY_SECRET!)
      .update(text)
      .digest('hex');

    return generatedSignature === signature;
  }

  // Step 3: Handle payment success
  async handlePaymentSuccess(
    orderId: string,
    paymentId: string,
    signature: string
  ) {
    // Verify signature first
    const isValid = this.verifyPaymentSignature(orderId, paymentId, signature);

    if (!isValid) {
      throw new Error('Invalid payment signature');
    }

    // Update order status
    await db.orders.update({
      where: { orderId },
      data: {
        paymentId,
        status: 'paid',
        paidAt: new Date(),
      },
    });

    // Fetch payment details
    const payment = await this.razorpay.payments.fetch(paymentId);

    // Process order (inventory, notifications, etc.)
    await this.processOrder(orderId);

    return { success: true, payment };
  }

  // Webhook handler for payment events
  async handleWebhook(payload: any, signature: string) {
    // Verify webhook signature
    const isValid = this.verifyWebhookSignature(payload, signature);

    if (!isValid) {
      throw new Error('Invalid webhook signature');
    }

    const event = payload.event;

    switch (event) {
      case 'payment.authorized':
        await this.handlePaymentAuthorized(payload.payload);
        break;
      case 'payment.captured':
        await this.handlePaymentCaptured(payload.payload);
        break;
      case 'payment.failed':
        await this.handlePaymentFailed(payload.payload);
        break;
      default:
        logger.warn(\`Unhandled webhook event: \${event}\`);
    }
  }

  private verifyWebhookSignature(payload: any, signature: string): boolean {
    const secret = process.env.RAZORPAY_WEBHOOK_SECRET!;
    const generatedSignature = crypto
      .createHmac('sha256', secret)
      .update(JSON.stringify(payload))
      .digest('hex');

    return generatedSignature === signature;
  }
}

export const paymentService = new PaymentService();`,
    language: "typescript"
  }
]} />

## Pattern 2: Shipping Integration (ShipRocket)

### Challenge: Multi-Carrier Logistics

<CodeBlock compact marginBottom="16" codes={[
  {
    code: `// services/shipping.service.ts
class ShippingService {
  private token: string | null = null;
  private tokenExpiry: Date | null = null;

  // Authentication with token refresh
  private async getToken(): Promise<string> {
    if (this.token && this.tokenExpiry && new Date() < this.tokenExpiry) {
      return this.token;
    }

    const response = await shiprocketClient.post<{ token: string }>('/auth/login', {
      email: process.env.SHIPROCKET_EMAIL,
      password: process.env.SHIPROCKET_PASSWORD,
    });

    this.token = response.token;
    this.tokenExpiry = new Date(Date.now() + 9 * 24 * 60 * 60 * 1000); // 9 days

    return this.token;
  }

  // Create shipment order
  async createShipment(orderData: ShipmentOrder) {
    const token = await this.getToken();

    const payload = {
      order_id: orderData.orderId,
      order_date: orderData.orderDate,
      pickup_location: orderData.pickupLocation,
      billing_customer_name: orderData.customer.name,
      billing_address: orderData.customer.address,
      billing_city: orderData.customer.city,
      billing_pincode: orderData.customer.pincode,
      billing_state: orderData.customer.state,
      billing_country: 'India',
      billing_email: orderData.customer.email,
      billing_phone: orderData.customer.phone,
      shipping_is_billing: true,
      order_items: orderData.items.map(item => ({
        name: item.name,
        sku: item.sku,
        units: item.quantity,
        selling_price: item.price,
      })),
      payment_method: orderData.paymentMethod,
      sub_total: orderData.subtotal,
      length: orderData.dimensions.length,
      breadth: orderData.dimensions.breadth,
      height: orderData.dimensions.height,
      weight: orderData.weight,
    };

    try {
      const response = await shiprocketClient.post('/orders/create/adhoc', payload, {
        headers: { Authorization: \`Bearer \${token}\` },
      });

      // Store shipment details
      await db.shipments.create({
        orderId: orderData.orderId,
        shipmentId: response.shipment_id,
        awb: response.awb_code,
        courierId: response.courier_id,
        courierName: response.courier_name,
        status: 'created',
      });

      return response;
    } catch (error) {
      logger.error('Shipment creation failed:', error);
      throw error;
    }
  }

  // Track shipment
  async trackShipment(shipmentId: string) {
    const token = await this.getToken();

    const response = await shiprocketClient.get(
      \`/courier/track/shipment/\${shipmentId}\`,
      {
        headers: { Authorization: \`Bearer \${token}\` },
      }
    );

    return {
      status: response.tracking_data.shipment_status,
      currentLocation: response.tracking_data.current_location,
      lastUpdated: response.tracking_data.last_updated_time,
      history: response.tracking_data.shipment_track,
    };
  }

  // Cancel shipment
  async cancelShipment(awb: string[]) {
    const token = await this.getToken();

    const response = await shiprocketClient.post(
      '/orders/cancel/shipment/awbs',
      { awbs: awb },
      { headers: { Authorization: \`Bearer \${token}\` } }
    );

    return response;
  }

  // Get available couriers for pincode
  async getAvailableCouriers(
    pickupPincode: string,
    deliveryPincode: string,
    weight: number,
    cod: boolean
  ) {
    const token = await this.getToken();

    const response = await shiprocketClient.get('/courier/serviceability', {
      params: {
        pickup_postcode: pickupPincode,
        delivery_postcode: deliveryPincode,
        weight,
        cod: cod ? 1 : 0,
      },
      headers: { Authorization: \`Bearer \${token}\` },
    });

    return response.data.available_courier_companies.map((courier: any) => ({
      id: courier.courier_company_id,
      name: courier.courier_name,
      estimatedDays: courier.etd,
      rate: courier.rate,
      cod_charges: courier.cod_charges,
    }));
  }
}

export const shippingService = new ShippingService();`,
    language: "typescript"
  }
]} />

## Pattern 3: Rate Limiting & Circuit Breaker

### Protecting Your App from API Failures

<CodeBlock compact marginBottom="16" codes={[
  {
    code: `// utils/rateLimiter.ts
import Bottleneck from 'bottleneck';

// Rate limiter for Razorpay (100 req/min)
export const razorpayLimiter = new Bottleneck({
  minTime: 600, // 600ms between requests = 100/min
  maxConcurrent: 5,
});

// Rate limiter for ShipRocket (200 req/min)
export const shiprocketLimiter = new Bottleneck({
  minTime: 300,
  maxConcurrent: 10,
});

// Usage
const createOrder = razorpayLimiter.wrap(async (data) => {
  return await paymentService.createOrder(data.amount, data.currency);
});

// utils/circuitBreaker.ts
class CircuitBreaker {
  private failureCount = 0;
  private successCount = 0;
  private lastFailureTime: Date | null = null;
  private state: 'CLOSED' | 'OPEN' | 'HALF_OPEN' = 'CLOSED';

  constructor(
    private threshold: number = 5,
    private timeout: number = 60000,
    private successThreshold: number = 2
  ) {}

  async execute<T>(fn: () => Promise<T>): Promise<T> {
    if (this.state === 'OPEN') {
      if (this.shouldAttemptReset()) {
        this.state = 'HALF_OPEN';
      } else {
        throw new Error('Circuit breaker is OPEN');
      }
    }

    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  private onSuccess() {
    this.failureCount = 0;

    if (this.state === 'HALF_OPEN') {
      this.successCount++;

      if (this.successCount >= this.successThreshold) {
        this.state = 'CLOSED';
        this.successCount = 0;
      }
    }
  }

  private onFailure() {
    this.failureCount++;
    this.lastFailureTime = new Date();

    if (this.failureCount >= this.threshold) {
      this.state = 'OPEN';
      logger.warn('Circuit breaker opened');
    }
  }

  private shouldAttemptReset(): boolean {
    return (
      this.lastFailureTime !== null &&
      Date.now() - this.lastFailureTime.getTime() >= this.timeout
    );
  }
}

// Usage
const shiprocketBreaker = new CircuitBreaker(5, 60000);

async function createShipmentWithBreaker(data: any) {
  return shiprocketBreaker.execute(() =>
    shippingService.createShipment(data)
  );
}`,
    language: "typescript"
  }
]} />

## Pattern 4: Webhook Handling

### Reliable Event Processing

<CodeBlock compact marginBottom="16" codes={[
  {
    code: `// routes/webhooks.ts
import express from 'express';
import { verifyWebhookSignature } from '../utils/security';

const router = express.Router();

// Razorpay webhook
router.post('/razorpay', express.raw({ type: 'application/json' }), async (req, res) => {
  try {
    const signature = req.headers['x-razorpay-signature'] as string;
    const payload = req.body;

    // Verify signature
    const isValid = verifyWebhookSignature(
      payload,
      signature,
      process.env.RAZORPAY_WEBHOOK_SECRET!
    );

    if (!isValid) {
      return res.status(401).json({ error: 'Invalid signature' });
    }

    // Queue webhook for processing (don't block response)
    await webhookQueue.add('razorpay-webhook', {
      event: payload.event,
      payload: payload.payload,
      receivedAt: new Date(),
    });

    // Respond immediately (important!)
    res.status(200).json({ status: 'received' });

    // Process asynchronously
    processRazorpayWebhook(payload).catch(error => {
      logger.error('Webhook processing failed:', error);
    });
  } catch (error) {
    logger.error('Webhook handling failed:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ShipRocket webhook
router.post('/shiprocket', async (req, res) => {
  try {
    const event = req.body;

    // Store webhook event
    await db.webhookEvents.create({
      source: 'shiprocket',
      event: event.status,
      data: event,
      receivedAt: new Date(),
    });

    res.status(200).json({ status: 'received' });

    // Process based on event type
    switch (event.status) {
      case 'DELIVERED':
        await handleDelivery(event);
        break;
      case 'RETURNED':
        await handleReturn(event);
        break;
      case 'CANCELLED':
        await handleCancellation(event);
        break;
    }
  } catch (error) {
    logger.error('ShipRocket webhook failed:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Webhook queue processor (Bull)
webhookQueue.process('razorpay-webhook', async (job) => {
  const { event, payload } = job.data;

  try {
    await paymentService.handleWebhook({ event, payload: { payment: { entity: payload } } }, '');

    // Mark as processed
    await db.webhookEvents.update({
      where: { id: job.data.id },
      data: { processed: true, processedAt: new Date() },
    });
  } catch (error) {
    logger.error('Webhook processing failed:', error);
    throw error; // Will retry
  }
});`,
    language: "typescript"
  }
]} />

## Pattern 5: API Response Caching

### Reduce API Calls and Improve Performance

<CodeBlock compact marginBottom="16" codes={[
  {
    code: `// utils/cache.ts
import Redis from 'ioredis';

const redis = new Redis(process.env.REDIS_URL);

export async function cacheWrapper<T>(
  key: string,
  ttl: number,
  fn: () => Promise<T>
): Promise<T> {
  // Try cache first
  const cached = await redis.get(key);

  if (cached) {
    logger.info('Cache hit:', key);
    return JSON.parse(cached);
  }

  // Cache miss - call API
  logger.info('Cache miss:', key);
  const result = await fn();

  // Store in cache
  await redis.setex(key, ttl, JSON.stringify(result));

  return result;
}

// Usage
async function getAvailableCouriers(pickupPin: string, deliveryPin: string) {
  const cacheKey = \`couriers:\${pickupPin}:\${deliveryPin}\`;

  return cacheWrapper(cacheKey, 3600, async () => {
    return await shippingService.getAvailableCouriers(
      pickupPin,
      deliveryPin,
      1, // weight
      false // COD
    );
  });
}`,
    language: "typescript"
  }
]} />

## Complete Integration Example: Order Flow

### Putting It All Together

<CodeBlock compact marginBottom="16" codes={[
  {
    code: `// services/order.service.ts
class OrderService {
  async createOrder(orderData: CreateOrderDTO) {
    const order = await db.orders.create({
      data: {
        userId: orderData.userId,
        items: orderData.items,
        subtotal: orderData.subtotal,
        total: orderData.total,
        status: 'pending',
      },
    });

    // Step 1: Create payment order
    const paymentOrder = await paymentService.createOrder(
      order.total,
      'INR'
    );

    await db.orders.update({
      where: { id: order.id },
      data: { razorpayOrderId: paymentOrder.orderId },
    });

    return {
      orderId: order.id,
      paymentOrderId: paymentOrder.orderId,
    };
  }

  async confirmOrder(
    orderId: string,
    paymentId: string,
    signature: string
  ) {
    // Step 2: Verify payment
    const order = await db.orders.findUnique({ where: { id: orderId } });

    await paymentService.handlePaymentSuccess(
      order.razorpayOrderId,
      paymentId,
      signature
    );

    // Step 3: Create shipment
    const shipment = await shippingService.createShipment({
      orderId: order.id,
      orderDate: new Date().toISOString(),
      pickupLocation: 'Main Warehouse',
      customer: order.shippingAddress,
      items: order.items,
      paymentMethod: 'Prepaid',
      subtotal: order.subtotal,
      weight: this.calculateWeight(order.items),
      dimensions: this.calculateDimensions(order.items),
    });

    // Step 4: Update inventory
    await this.updateInventory(order.items);

    // Step 5: Send notifications
    await this.sendOrderConfirmation(order);

    // Step 6: Update order status
    await db.orders.update({
      where: { id: orderId },
      data: {
        status: 'confirmed',
        shipmentId: shipment.shipment_id,
        awb: shipment.awb_code,
      },
    });

    return { success: true, order };
  }

  private async sendOrderConfirmation(order: any) {
    // Email notification
    await emailService.send({
      to: order.customer.email,
      template: 'order-confirmation',
      data: order,
    });

    // SMS notification
    await smsService.send({
      to: order.customer.phone,
      message: \`Order #\${order.id} confirmed. Track: \${order.awb}\`,
    });

    // WhatsApp notification (optional)
    await whatsappService.send({
      to: order.customer.phone,
      template: 'order_confirmation',
      params: [order.id, order.awb],
    });
  }
}`,
    language: "typescript"
  }
]} />

## Testing API Integrations

### Mock External APIs for Testing

<CodeBlock compact marginBottom="16" codes={[
  {
    code: `// __tests__/payment.test.ts
import { paymentService } from '../services/payment.service';
import nock from 'nock';

describe('PaymentService', () => {
  beforeEach(() => {
    nock.cleanAll();
  });

  it('should create order successfully', async () => {
    // Mock Razorpay API
    nock('https://api.razorpay.com')
      .post('/v1/orders')
      .reply(200, {
        id: 'order_123',
        amount: 100000,
        currency: 'INR',
        status: 'created',
      });

    const result = await paymentService.createOrder(1000, 'INR');

    expect(result.orderId).toBe('order_123');
    expect(result.amount).toBe(100000);
  });

  it('should verify payment signature', () => {
    const orderId = 'order_123';
    const paymentId = 'pay_456';
    const signature = 'generated_signature';

    const isValid = paymentService.verifyPaymentSignature(
      orderId,
      paymentId,
      signature
    );

    expect(typeof isValid).toBe('boolean');
  });
});`,
    language: "typescript"
  }
]} />

## Monitoring & Observability

### Track API Performance

<CodeBlock compact marginBottom="16" codes={[
  {
    code: `// middleware/apiMetrics.ts
import { Counter, Histogram } from 'prom-client';

const apiRequestCounter = new Counter({
  name: 'api_requests_total',
  help: 'Total API requests',
  labelNames: ['service', 'endpoint', 'status'],
});

const apiRequestDuration = new Histogram({
  name: 'api_request_duration_seconds',
  help: 'API request duration',
  labelNames: ['service', 'endpoint'],
  buckets: [0.1, 0.5, 1, 2, 5],
});

export function trackAPICall(service: string, endpoint: string) {
  return async function<T>(fn: () => Promise<T>): Promise<T> {
    const start = Date.now();

    try {
      const result = await fn();

      // Success metrics
      apiRequestCounter.inc({
        service,
        endpoint,
        status: 'success',
      });

      return result;
    } catch (error) {
      // Error metrics
      apiRequestCounter.inc({
        service,
        endpoint,
        status: 'error',
      });

      throw error;
    } finally {
      // Duration metric
      const duration = (Date.now() - start) / 1000;
      apiRequestDuration.observe({ service, endpoint }, duration);
    }
  };
}

// Usage
const createOrderWithMetrics = trackAPICall('razorpay', 'create_order')(
  () => razorpay.orders.create(orderData)
);`,
    language: "typescript"
  }
]} />

## Key Takeaways from Sahyog Medico

**What Worked:**
1. Centralized HTTP client saved weeks of debugging
2. Circuit breaker prevented cascading failures
3. Webhook queue ensured zero data loss
4. Caching reduced API costs by 60%
5. Comprehensive logging made debugging easy

**What to Avoid:**
1. Don't trust external APIs blindly—always validate
2. Never block webhook responses
3. Always implement retries with exponential backoff
4. Don't store sensitive API keys in code
5. Monitor API usage to avoid rate limits

**Results:**
- 99.8% payment success rate
- Zero lost webhooks
- 40% reduction in API costs through caching
- 300ms average order processing time
- Seamless multi-carrier shipping

## Conclusion

API integration is where theory meets reality. These patterns emerged from building a production B2B marketplace handling real payments, logistics, and customer expectations.

**Remember:**
- Plan for failures—APIs will fail
- Implement observability from day one
- Test with mocked APIs
- Monitor usage and costs
- Document everything

**The difference between a working integration and a production-ready integration is error handling, monitoring, and resilience.**

---

*Based on production experience building Sahyog Medico's B2B marketplace, processing thousands of orders monthly with Razorpay payments and ShipRocket logistics integration.*
